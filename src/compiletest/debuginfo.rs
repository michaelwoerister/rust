
use std::io::{BufferedReader, File};

use common::Config;
use header::TestProps;
use procsrv::{ProcRes, ProcArgs};
use util;

pub trait Debugger {
	fn name<'a>(&'a self) -> &'a str;

	// Run the debugger
    fn run(&self, config: &Config, executable: &Path) -> ProcRes;

    // Check the output generated by the run command
    fn check_output(&self, debugger_output: &str) -> Result<(), ~str>;
}

pub type DebuggerFactory = fn(&Path, &Config, &TestProps) -> Option<~Debugger:>;

pub static DEBUGGER_FACTORIES: [DebuggerFactory, ..1] = [
	new_gdb
];

struct Gdb {
	script_path: Path,
	check_lines: ~[~str]
}

fn new_gdb(test_file: &Path, config: &Config, test_props: &TestProps) -> Option<~Debugger:> {
	Gdb::new(test_file, config, test_props)
}

impl Gdb {
	fn new(test_file: &Path, config: &Config, test_props: &TestProps) -> Option<~Debugger:> {

		let PREFIX = "gdb:";

		let mut script = ~"set charset UTF-8\n";

		let mut reader = BufferedReader::new(File::open(test_file).unwrap());
	    for line in reader.lines() {
	        let line = line.trim();

	        if line.contains("gdb-ignore") {
	        	return None;
	        }

	        if line.starts_with(PREFIX) {
	        	script.push_str(line.slice_from(PREFIX.len()).trim());
	        	script.push_str("\n");
	        }
	    }

	    script.push_str("quit\n");

	    util::dump_output_file(config, test_file, script, "debugger.script");

	    Some(~Gdb {
	    	script_path: util::make_out_name(config, test_file, "debugger.script"),
	    	check_lines: test_props.check_lines.clone(),
	    } as ~Debugger:)
	}
}

impl Debugger for Gdb {

	fn name<'a>(&'a self) -> &'a str {
		"gdb"
	}

	// Run the debugger
    fn run(&self, config: &Config, executable: &Path) -> ProcRes {
    	// run debugger script with gdb
        #[cfg(windows)]
        fn debugger() -> ~str { ~"gdb.exe" }
        #[cfg(unix)]
        fn debugger() -> ~str { ~"gdb" }

        // FIXME (#9639): This needs to handle non-utf8 paths
        let debugger_opts = ~[~"-quiet", ~"-batch", ~"-nx",
            "-command=" + self.script_path.as_str().unwrap().to_owned(),
            executable.as_str().unwrap().to_owned()];
        let proc_args = ProcArgs {prog: debugger(), args: debugger_opts};
        util::compose_and_run(config, executable, proc_args, ~[], "", None)
    }

    // Check the output generated by the run command
    fn check_output(&self, debugger_output: &str) -> Result<(), ~str> {
    	let num_check_lines = self.check_lines.len();

    	if num_check_lines == 0 {
    		return Ok(());
    	}

    	// Allow check lines to leave parts unspecified (e.g., uninitialized
	    // bits in the wrong case of an enum) with the notation "[...]".
	    let check_fragments: ~[~[&str]] = self.check_lines.map(|s| s.split_str("[...]").collect());
	    // check if each line in props.check_lines appears in the
		// output (in order)
		let mut i = 0u;
		for line in debugger_output.lines() {
            let mut rest = line.trim();
            let mut first = true;
            let mut failed = false;
            for &frag in check_fragments[i].iter() {
                let found = if first {
                    if rest.starts_with(frag) { Some(0) } else { None }
                } else {
                    rest.find_str(frag)
                };
                match found {
                    None => {
                        failed = true;
                        break;
                    }
                    Some(i) => {
                        rest = rest.slice_from(i + frag.len());
                    }
                }
                first = false;
            }
            if !failed && rest.len() == 0 {
                i += 1u;
            }
            if i == num_check_lines {
                // all lines checked
                break;
            }
        }

        if i != num_check_lines {
            Err(format!("line not found in debugger output: {}", self.check_lines[i]))
        } else {
        	Ok(())
        }
	}
}
